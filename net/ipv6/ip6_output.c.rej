--- net/ipv6/ip6_output.c
+++ net/ipv6/ip6_output.c
@@ -1144,7 +1137,7 @@ int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct inet_cork *cork;
 	struct sk_buff *skb, *skb_prev = NULL;
-	unsigned int maxfraglen, fragheaderlen, mtu, orig_mtu, pmtu;
+	unsigned int maxfraglen, fragheaderlen, mtu, orig_mtu;
 	int exthdrlen;
 	int dst_exthdrlen;
 	int hh_len;
@@ -1250,12 +1241,6 @@ int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 		else
 			maxnonfragsize = mtu;
 
-		/* as per RFC 7112 section 5, the entire IPv6 Header Chain must fit
-		 * the first fragment
-		 */
-		if (headersize + transhdrlen > mtu)
-			goto emsgsize;
-
 		/* dontfrag active */
 		if ((cork->length + length > mtu - headersize) && dontfrag &&
 		    (sk->sk_protocol == IPPROTO_UDP ||
@@ -1267,8 +1252,9 @@ int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 
 		if (cork->length + length > maxnonfragsize - headersize) {
 emsgsize:
-			pmtu = max_t(int, mtu - headersize + sizeof(struct ipv6hdr), 0);
-			ipv6_local_error(sk, EMSGSIZE, fl6, pmtu);
+			ipv6_local_error(sk, EMSGSIZE, fl6,
+					 mtu - headersize +
+					 sizeof(struct ipv6hdr));
 			return -EMSGSIZE;
 		}
 	}
