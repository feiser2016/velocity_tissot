--- fs/overlayfs/inode.c
+++ fs/overlayfs/inode.c
@@ -253,23 +248,12 @@ ssize_t ovl_getxattr(struct dentry *dentry, const char *name,
 	return vfs_getxattr(realpath.dentry, name, value, size);
 }
 
-static bool ovl_can_list(const char *s)
-{
-	/* List all non-trusted xatts */
-	if (strncmp(s, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) != 0)
-		return true;
-
-	/* Never list trusted.overlay, list other trusted for superuser only */
-	return !ovl_is_private_xattr(s) && capable(CAP_SYS_ADMIN);
-}
-
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size)
 {
 	struct path realpath;
 	enum ovl_path_type type = ovl_path_real(dentry, &realpath);
 	ssize_t res;
-	size_t len;
-	char *s;
+	int off;
 
 	res = vfs_listxattr(realpath.dentry, list, size);
 	if (res <= 0 || size == 0)
@@ -279,19 +263,17 @@ ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size)
 		return res;
 
 	/* filter out private xattrs */
-	for (s = list, len = res; len;) {
-		size_t slen = strnlen(s, len) + 1;
+	for (off = 0; off < res;) {
+		char *s = list + off;
+		size_t slen = strlen(s) + 1;
 
-		/* underlying fs providing us with an broken xattr list? */
-		if (WARN_ON(slen > len))
-			return -EIO;
+		BUG_ON(off + slen > res);
 
-		len -= slen;
-		if (!ovl_can_list(s)) {
+		if (ovl_is_private_xattr(s)) {
 			res -= slen;
-			memmove(s, s + slen, len);
+			memmove(s, s + slen, res - off);
 		} else {
-			s += slen;
+			off += slen;
 		}
 	}
 
