--- drivers/usb/dwc3/dwc3-exynos.c
+++ drivers/usb/dwc3/dwc3-exynos.c
@@ -106,6 +106,7 @@ static int dwc3_exynos_remove_child(struct device *dev, void *unused)
 static int dwc3_exynos_probe(struct platform_device *pdev)
 {
 	struct dwc3_exynos	*exynos;
+	struct clk		*clk;
 	struct device		*dev = &pdev->dev;
 	struct device_node	*node = dev->of_node;
 
@@ -126,13 +127,21 @@ static int dwc3_exynos_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, exynos);
 
-	exynos->dev	= dev;
+	ret = dwc3_exynos_register_phys(exynos);
+	if (ret) {
+		dev_err(dev, "couldn't register PHYs\n");
+		return ret;
+	}
 
-	exynos->clk = devm_clk_get(dev, "usbdrd30");
-	if (IS_ERR(exynos->clk)) {
+	clk = devm_clk_get(dev, "usbdrd30");
+	if (IS_ERR(clk)) {
 		dev_err(dev, "couldn't get clock\n");
 		return -EINVAL;
 	}
+
+	exynos->dev	= dev;
+	exynos->clk	= clk;
+
 	clk_prepare_enable(exynos->clk);
 
 	exynos->vdd33 = devm_regulator_get(dev, "vdd33");
@@ -157,35 +166,26 @@ static int dwc3_exynos_probe(struct platform_device *pdev)
 		goto err3;
 	}
 
-	ret = dwc3_exynos_register_phys(exynos);
-	if (ret) {
-		dev_err(dev, "couldn't register PHYs\n");
-		goto err4;
-	}
-
 	if (node) {
 		ret = of_platform_populate(node, NULL, NULL, dev);
 		if (ret) {
 			dev_err(dev, "failed to add dwc3 core\n");
-			goto err5;
+			goto err4;
 		}
 	} else {
 		dev_err(dev, "no device node, failed to add dwc3 core\n");
 		ret = -ENODEV;
-		goto err5;
+		goto err4;
 	}
 
 	return 0;
 
-err5:
-	platform_device_unregister(exynos->usb2_phy);
-	platform_device_unregister(exynos->usb3_phy);
 err4:
 	regulator_disable(exynos->vdd10);
 err3:
 	regulator_disable(exynos->vdd33);
 err2:
-	clk_disable_unprepare(exynos->clk);
+	clk_disable_unprepare(clk);
 	return ret;
 }
 
