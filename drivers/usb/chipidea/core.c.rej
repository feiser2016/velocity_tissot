--- drivers/usb/chipidea/core.c
+++ drivers/usb/chipidea/core.c
@@ -553,7 +553,7 @@ static inline void ci_role_destroy(struct ci_hdrc *ci)
 {
 	ci_hdrc_gadget_destroy(ci);
 	ci_hdrc_host_destroy(ci);
-	if (ci->is_otg && ci->roles[CI_ROLE_GADGET])
+	if (ci->is_otg)
 		ci_hdrc_otg_destroy(ci);
 }
 
@@ -594,7 +594,6 @@ static int ci_hdrc_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
-	spin_lock_init(&ci->lock);
 	ci->dev = dev;
 	ci->platdata = dev_get_platdata(dev);
 	ci->imx28_write_fix = !!(ci->platdata->flags &
@@ -653,28 +652,20 @@ static int ci_hdrc_probe(struct platform_device *pdev)
 	/* initialize role(s) before the interrupt is requested */
 	if (dr_mode == USB_DR_MODE_OTG || dr_mode == USB_DR_MODE_HOST) {
 		ret = ci_hdrc_host_init(ci);
-		if (ret) {
-			if (ret == -ENXIO)
-				dev_info(dev, "doesn't support host\n");
-			else
-				goto deinit_phy;
-		}
+		if (ret)
+			dev_info(dev, "doesn't support host\n");
 	}
 
 	if (dr_mode == USB_DR_MODE_OTG || dr_mode == USB_DR_MODE_PERIPHERAL) {
 		ret = ci_hdrc_gadget_init(ci);
-		if (ret) {
-			if (ret == -ENXIO)
-				dev_info(dev, "doesn't support gadget\n");
-			else
-				goto deinit_host;
-		}
+		if (ret)
+			dev_info(dev, "doesn't support gadget\n");
 	}
 
 	if (!ci->roles[CI_ROLE_HOST] && !ci->roles[CI_ROLE_GADGET]) {
 		dev_err(dev, "no supported roles\n");
 		ret = -ENODEV;
-		goto deinit_gadget;
+		goto deinit_phy;
 	}
 
 	if (ci->is_otg && ci->roles[CI_ROLE_GADGET]) {
@@ -684,7 +675,7 @@ static int ci_hdrc_probe(struct platform_device *pdev)
 		ret = ci_hdrc_otg_init(ci);
 		if (ret) {
 			dev_err(dev, "init otg fails, ret = %d\n", ret);
-			goto deinit_gadget;
+			goto stop;
 		}
 	}
 
@@ -735,12 +726,7 @@ static int ci_hdrc_probe(struct platform_device *pdev)
 
 	free_irq(ci->irq, ci);
 stop:
-	if (ci->is_otg && ci->roles[CI_ROLE_GADGET])
-		ci_hdrc_otg_destroy(ci);
-deinit_gadget:
-	ci_hdrc_gadget_destroy(ci);
-deinit_host:
-	ci_hdrc_host_destroy(ci);
+	ci_role_destroy(ci);
 deinit_phy:
 	usb_phy_shutdown(ci->transceiver);
 
