--- drivers/usb/chipidea/udc.c
+++ drivers/usb/chipidea/udc.c
@@ -638,44 +638,6 @@ __acquires(hwep->lock)
 	return 0;
 }
 
-static int _ep_set_halt(struct usb_ep *ep, int value, bool check_transfer)
-{
-	struct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);
-	int direction, retval = 0;
-	unsigned long flags;
-
-	if (ep == NULL || hwep->ep.desc == NULL)
-		return -EINVAL;
-
-	if (usb_endpoint_xfer_isoc(hwep->ep.desc))
-		return -EOPNOTSUPP;
-
-	spin_lock_irqsave(hwep->lock, flags);
-
-	if (value && hwep->dir == TX && check_transfer &&
-		!list_empty(&hwep->qh.queue) &&
-			!usb_endpoint_xfer_control(hwep->ep.desc)) {
-		spin_unlock_irqrestore(hwep->lock, flags);
-		return -EAGAIN;
-	}
-
-	direction = hwep->dir;
-	do {
-		retval |= hw_ep_set_halt(hwep->ci, hwep->num, hwep->dir, value);
-
-		if (!value)
-			hwep->wedge = 0;
-
-		if (hwep->type == USB_ENDPOINT_XFER_CONTROL)
-			hwep->dir = (hwep->dir == TX) ? RX : TX;
-
-	} while (hwep->dir != direction);
-
-	spin_unlock_irqrestore(hwep->lock, flags);
-	return retval;
-}
-
-
 /**
  * _gadget_stop_activity: stops all USB activity, flushes & disables all endpts
  * @gadget: gadget
@@ -971,13 +933,6 @@ __acquires(hwep->lock)
 	return retval;
 }
 
-static int otg_a_alt_hnp_support(struct ci_hdrc *ci)
-{
-	dev_warn(&ci->gadget.dev,
-		"connect the device to an alternate port if you want HNP\n");
-	return isr_setup_status_phase(ci);
-}
-
 /**
  * isr_setup_packet_handler: setup packet handler
  * @ci: UDC descriptor
@@ -1075,7 +1030,7 @@ __acquires(ci->lock)
 				num += ci->hw_ep_max / 2;
 
 			spin_unlock(&ci->lock);
-			err = _ep_set_halt(&ci->ci_hw_ep[num].ep, 1, false);
+			err = usb_ep_set_halt(&ci->ci_hw_ep[num].ep);
 			spin_lock(&ci->lock);
 			if (!err)
 				isr_setup_status_phase(ci);
@@ -1110,10 +1065,6 @@ __acquires(ci->lock)
 							ci);
 				}
 				break;
-			case USB_DEVICE_A_ALT_HNP_SUPPORT:
-				if (ci_otg_is_fsm_mode(ci))
-					err = otg_a_alt_hnp_support(ci);
-				break;
 			default:
 				goto delegate;
 			}
@@ -1134,8 +1085,8 @@ delegate:
 
 	if (err < 0) {
 		spin_unlock(&ci->lock);
-		if (_ep_set_halt(&hwep->ep, 1, false))
-			dev_err(ci->dev, "error: _ep_set_halt\n");
+		if (usb_ep_set_halt(&hwep->ep))
+			dev_err(ci->dev, "error: ep_set_halt\n");
 		spin_lock(&ci->lock);
 	}
 }
@@ -1166,9 +1117,9 @@ __acquires(ci->lock)
 					err = isr_setup_status_phase(ci);
 				if (err < 0) {
 					spin_unlock(&ci->lock);
-					if (_ep_set_halt(&hwep->ep, 1, false))
+					if (usb_ep_set_halt(&hwep->ep))
 						dev_err(ci->dev,
-						"error: _ep_set_halt\n");
+							"error: ep_set_halt\n");
 					spin_lock(&ci->lock);
 				}
 			}
@@ -1411,7 +1362,41 @@ static int ep_dequeue(struct usb_ep *ep, struct usb_request *req)
  */
 static int ep_set_halt(struct usb_ep *ep, int value)
 {
-	return _ep_set_halt(ep, value, true);
+	struct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);
+	int direction, retval = 0;
+	unsigned long flags;
+
+	if (ep == NULL || hwep->ep.desc == NULL)
+		return -EINVAL;
+
+	if (usb_endpoint_xfer_isoc(hwep->ep.desc))
+		return -EOPNOTSUPP;
+
+	spin_lock_irqsave(hwep->lock, flags);
+
+#ifndef STALL_IN
+	/* g_file_storage MS compliant but g_zero fails chapter 9 compliance */
+	if (value && hwep->type == USB_ENDPOINT_XFER_BULK && hwep->dir == TX &&
+	    !list_empty(&hwep->qh.queue)) {
+		spin_unlock_irqrestore(hwep->lock, flags);
+		return -EAGAIN;
+	}
+#endif
+
+	direction = hwep->dir;
+	do {
+		retval |= hw_ep_set_halt(hwep->ci, hwep->num, hwep->dir, value);
+
+		if (!value)
+			hwep->wedge = 0;
+
+		if (hwep->type == USB_ENDPOINT_XFER_CONTROL)
+			hwep->dir = (hwep->dir == TX) ? RX : TX;
+
+	} while (hwep->dir != direction);
+
+	spin_unlock_irqrestore(hwep->lock, flags);
+	return retval;
 }
 
 /**
@@ -1798,6 +1783,8 @@ static int udc_start(struct ci_hdrc *ci)
 	struct device *dev = ci->dev;
 	int retval = 0;
 
+	spin_lock_init(&ci->lock);
+
 	ci->gadget.ops          = &usb_gadget_ops;
 	ci->gadget.speed        = USB_SPEED_UNKNOWN;
 	ci->gadget.max_speed    = USB_SPEED_HIGH;
@@ -1892,7 +1879,6 @@ static void udc_id_switch_for_host(struct ci_hdrc *ci)
 int ci_hdrc_gadget_init(struct ci_hdrc *ci)
 {
 	struct ci_role_driver *rdrv;
-	int ret;
 
 	if (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_DC))
 		return -ENXIO;
@@ -1905,10 +1891,7 @@ int ci_hdrc_gadget_init(struct ci_hdrc *ci)
 	rdrv->stop	= udc_id_switch_for_host;
 	rdrv->irq	= udc_irq;
 	rdrv->name	= "gadget";
+	ci->roles[CI_ROLE_GADGET] = rdrv;
 
-	ret = udc_start(ci);
-	if (!ret)
-		ci->roles[CI_ROLE_GADGET] = rdrv;
-
-	return ret;
+	return udc_start(ci);
 }
