--- drivers/net/usb/catc.c
+++ drivers/net/usb/catc.c
@@ -777,7 +777,7 @@ static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id
 	struct net_device *netdev;
 	struct catc *catc;
 	u8 broadcast[ETH_ALEN];
-	int pktsz, ret;
+	int i, pktsz;
 
 	if (usb_set_interface(usbdev,
 			intf->altsetting->desc.bInterfaceNumber, 1)) {
@@ -812,8 +812,12 @@ static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id
 	if ((!catc->ctrl_urb) || (!catc->tx_urb) || 
 	    (!catc->rx_urb) || (!catc->irq_urb)) {
 		dev_err(&intf->dev, "No free urbs available.\n");
-		ret = -ENOMEM;
-		goto fail_free;
+		usb_free_urb(catc->ctrl_urb);
+		usb_free_urb(catc->tx_urb);
+		usb_free_urb(catc->rx_urb);
+		usb_free_urb(catc->irq_urb);
+		free_netdev(netdev);
+		return -ENOMEM;
 	}
 
 	/* The F5U011 has the same vendor/product as the netmate but a device version of 0x130 */
@@ -841,24 +845,15 @@ static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id
                 catc->irq_buf, 2, catc_irq_done, catc, 1);
 
 	if (!catc->is_f5u011) {
-		u32 *buf;
-		int i;
-
 		dev_dbg(dev, "Checking memory size\n");
 
-		buf = kmalloc(4, GFP_KERNEL);
-		if (!buf) {
-			ret = -ENOMEM;
-			goto fail_free;
-		}
-
-		*buf = 0x12345678;
-		catc_write_mem(catc, 0x7a80, buf, 4);
-		*buf = 0x87654321;
-		catc_write_mem(catc, 0xfa80, buf, 4);
-		catc_read_mem(catc, 0x7a80, buf, 4);
+		i = 0x12345678;
+		catc_write_mem(catc, 0x7a80, &i, 4);
+		i = 0x87654321;	
+		catc_write_mem(catc, 0xfa80, &i, 4);
+		catc_read_mem(catc, 0x7a80, &i, 4);
 	  
-		switch (*buf) {
+		switch (i) {
 		case 0x12345678:
 			catc_set_reg(catc, TxBufCount, 8);
 			catc_set_reg(catc, RxBufCount, 32);
@@ -873,8 +868,6 @@ static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id
 			dev_dbg(dev, "32k Memory\n");
 			break;
 		}
-
-		kfree(buf);
 	  
 		dev_dbg(dev, "Getting MAC from SEEROM.\n");
 	  
@@ -921,21 +914,16 @@ static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id
 	usb_set_intfdata(intf, catc);
 
 	SET_NETDEV_DEV(netdev, &intf->dev);
-	ret = register_netdev(netdev);
-	if (ret)
-		goto fail_clear_intfdata;
-
+	if (register_netdev(netdev) != 0) {
+		usb_set_intfdata(intf, NULL);
+		usb_free_urb(catc->ctrl_urb);
+		usb_free_urb(catc->tx_urb);
+		usb_free_urb(catc->rx_urb);
+		usb_free_urb(catc->irq_urb);
+		free_netdev(netdev);
+		return -EIO;
+	}
 	return 0;
-
-fail_clear_intfdata:
-	usb_set_intfdata(intf, NULL);
-fail_free:
-	usb_free_urb(catc->ctrl_urb);
-	usb_free_urb(catc->tx_urb);
-	usb_free_urb(catc->rx_urb);
-	usb_free_urb(catc->irq_urb);
-	free_netdev(netdev);
-	return ret;
 }
 
 static void catc_disconnect(struct usb_interface *intf)
