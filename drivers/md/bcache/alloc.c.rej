--- drivers/md/bcache/alloc.c
+++ drivers/md/bcache/alloc.c
@@ -513,21 +512,15 @@ struct open_bucket {
 
 /*
  * We keep multiple buckets open for writes, and try to segregate different
- * write streams for better cache utilization: first we try to segregate flash
- * only volume write streams from cached devices, secondly we look for a bucket
- * where the last write to it was sequential with the current write, and
- * failing that we look for a bucket that was last used by the same task.
+ * write streams for better cache utilization: first we look for a bucket where
+ * the last write to it was sequential with the current write, and failing that
+ * we look for a bucket that was last used by the same task.
  *
  * The ideas is if you've got multiple tasks pulling data into the cache at the
  * same time, you'll get better cache utilization if you try to segregate their
  * data and preserve locality.
  *
- * For example, dirty sectors of flash only volume is not reclaimable, if their
- * dirty sectors mixed with dirty sectors of cached device, such buckets will
- * be marked as dirty and won't be reclaimed, though the dirty data of cached
- * device have been written back to backend device.
- *
- * And say you've starting Firefox at the same time you're copying a
+ * For example, say you've starting Firefox at the same time you're copying a
  * bunch of files. Firefox will likely end up being fairly hot and stay in the
  * cache awhile, but the data you copied might not be; if you wrote all that
  * data to the same buckets it'd get invalidated at the same time.
@@ -544,10 +537,7 @@ static struct open_bucket *pick_data_bucket(struct cache_set *c,
 	struct open_bucket *ret, *ret_task = NULL;
 
 	list_for_each_entry_reverse(ret, &c->data_buckets, list)
-		if (UUID_FLASH_ONLY(&c->uuids[KEY_INODE(&ret->key)]) !=
-		    UUID_FLASH_ONLY(&c->uuids[KEY_INODE(search)]))
-			continue;
-		else if (!bkey_cmp(&ret->key, search))
+		if (!bkey_cmp(&ret->key, search))
 			goto found;
 		else if (ret->last_write_point == write_point)
 			ret_task = ret;
